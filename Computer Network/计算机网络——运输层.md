---
title: 计算机网络——运输层
date: 2021-3-23 17:10:55
tags: 
- Computer Network
categories:
- Computer Network
toc: true
reward: true
---

<!--more-->

运输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。该层为运行在不同主机上的**应用进程**提供直接的**逻辑通信**服务起着至关重要的作用。

## 3.1 概述和运输层服务

- 运输层协议是在**端系统**中而不是在路由器中实现的。
- 在发送端，运输层将从发送应用程序进程的报文转换成**运输层分组（报文段）**。实现的方法可能是将应用报文划分为较小的**块**，并为每块加上一个**运输层首部**以生成运输层报文段。然后，运输层将这些报文段传递给网络层，网络层将其封装成网络层分组（数据报）并向目的地发送。
- 在接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层。运输层则处理接收到的报文段，使该报文段中的数据为接收应用程序使用。

### 运输层和网络层的关系

- 运输层提供的是不同主机上**进程**之间的逻辑通信，而网络层提供的则是**主机**之间的逻辑通信。
- 运输层协议只是运行在**端系统**中，将来自应用层进程的报文移动到网络边缘（网络层），并不关心其在网络核心如何移动；在网络层，中间路由器既不处理也不识别运输层加在应用层报文的任何信息。
- 运输层协议能够提供的服务受制于网络层协议的服务模型，但是即使底层网络协议不能在网络层提供相应的服务，运输层协议**也能**提供某些服务，比如**可靠的数据传输服务**。

### 协议概述

网络层中 **IP** 的服务模型是**尽力而为交付服务**，**但并不做任何保证**。每台主机都有一个 IP 地址，UDP 和 TCP 最基本的任务是：将两个端系统间 IP 的交付任务扩展为运行在端系统上的两个进程之间的交付任务。将主机间交付扩展到进程间交付被称为**运输层的多路复用和多路分解**。

**UDP**：

- 不可靠、无连接
- 最低限度的运输层服务：数据交付、差错检查
- 应用程序可以根据其需要以任意的速率发送数据

**TCP**：

- 可靠的、面向连接的
- 通过流量控制、序号、确认和定时器
- 拥塞控制

## 3.2 多路复用和多路分解

![image-20210321141230590.png](https://static01.imgkr.com/temp/9547f364b96b4dd5a9198cda123e6e50.png)

- **多路分解**：将运输层报文段中的数据交付到正确的套接字的工作。

  报文段 --> 首部 + 报文；

  网络层 --> 运输层 --> (socket) --> 应用层（自底向上）

- **多路复用**：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用。

  首部 + 报文 --> 报文段

  应用层 --> (socket) --> 运输层 --> 网络层（自顶向下）

  **要求：① 套接字有唯一标识符；② 每个报文段有特殊字段来指示该报文段所要交付到的套接字。**

  特殊字段：

  - 源端口号字段
  - 目的端口号字段

![image-20210321141610647.png](https://static01.imgkr.com/temp/8dc520ec02c24c64a861e60a8e06f72f.png)

> 端口号是一个 16 比特的数，0 ~ 1023 范围的端口号称为**周知端口号**，是受限制（保留）的。

通常，应用程序的客户端让运输层**自动地**为其分配端口号，而服务器端则分配一个**特定**的端口号。

- 一个 UDP 套接字是由一个**二元组**全面标识的，该二元组包含一个**目的 IP 地址**和一个**目的端口号**。因此，如果两个 UDP 报文段有不同的源 IP 地址和/或源端口号，但具有相同的**目的 IP 地址和目的端口号**，那么这两个报文段将通过**相同**的目的套接字被定向到**相同**的目的进程。
- 一个TCP 套接字是由一个**四元组**全面标识的**（源 IP 地址，源端口号，目的 IP 地址，目的端口号）**，因此与 UDP 不同，即使目的 IP 地址和目的端口号都相同，但源 IP 地址和/或源端口号不同，那就会被定向到两个**不同**的套接字。服务器主机可以支持很多并行的 TCP 套接字，每个套接字与一个进程相联系，并由其四元组来标识每个套接字。
- 但连接套接字与进程之间也并非总是一一对应，很多高性能 Web 服务器通常只使用**一个进程**，但为每个新的客户连接创建一个具有新连接套接字的**新线程**。

## 3.3 无连接运输：UDP

- UDP 做了运输协议能够做的最少工作，除了复用/分解功能及少量的差错检测外，几乎没有对 IP 增加别的东西。
- 虽然 TCP 提供了可靠数据传输服务，但它并不总是首选（比如 DNS 通常使用 UDP），原因是：
  - 关于发送什么数据以及何时发送的应用层控制更为精细（**时效性**），而 TCP 有拥塞控制机制。
  - 无须连接建立（**低时延**），TCP 的三次握手会引入较大的连接时延。
  - 无连接状态，TCP 需要在端系统中维持连接状态，选用 UDP，**一般能支持更多的活跃用户**。
  - **分组首部开销小**，UDP 8 字节，TCP 20 字节。
- UDP 常用于承载网络管理数据（SNMP），因为网络管理应用程序通常必须在该网络处于重压下运行，此时 TCP 难以实现。
- 使用 UDP 的应用是**可能实现可靠数据传输的**，这可通过在**应用程序自身中**建立可靠性机制来完成。

### 报文结构

![image-20210321165056566](https://static01.imgkr.com/temp/fcb83069ebcd48388f027fe0b8ed62f8.png)

首部只有四个字段，其中长度字段指示了 UDP 报文段中的字节数（首部加数据）；接收方使用检验和来检查在该报文中是否出现了差错。

### UDP 检验和

发送方的 UDP 对报文段中**所有 16 比特字的和**进行**反码**运算，求和时遇到的任何溢出都将被**回卷**（回到第一位）。

> 假定有三个 16 比特的字：
>
> $$0110011001100000\\\ 0101010101010101\\\ 1000111100001100$$
>
> 前两个之和：
>
> $$0110011001100000\\\ 0101010101010101$$
>
> $$=> 1011101110110101$$
>
> 加上第三个字：
>
> $$1011101110110101\\\ 1000111100001100$$
>
> $$=> 0100101011000010$$（最高位 1 + 1 回卷到第一位）
>
> 取反码：
>
> $$1011010100111101$$

在接收方，将所有 16 比特字加在一起（**包括检验和**），如果没有差错，那么接收方的和将是**全 1**（1111111111111111）。

> 为什么要引入差错检测？因为不能保证源到目的地之间的所有链路都提供差错检测，UDP 必须在**端到端**的基础上在运输层提供差错检测。
>
> **端到端原则**表示为因为某种功能（在此时为差错检测）必须基于端到端实现：“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的。

虽然 UDP 提供差错检测，但它对**差错恢复**无能为力。UDP 的某种实现只是丢弃受损的报文段；或者将受损的报文段交给应用程序并给出警告。

## 3.4 可靠数据传输原理

![image-20210321203343826](https://static01.imgkr.com/temp/6cf90aefc08f44c7a9733845d3d1a02d.png)

- TCP 是在**不可靠**的（IP）端到端网络层之上实现的可靠数据传输协议。
- rdt（可靠数据传输）的发送端和接收端都要通过调用 `udt_send()` 发送分组给对方（udt 表示不可靠数据传输）。

### 构造可靠数据传输协议

#### 经完全可靠信道的可靠数据传输：rdt 1.0

最简单的情况：底层信道完全可靠，并且假定接收方接收数据的速率能够与发送方发送数据的速率一样快。

**有限状态机**：引起变迁的**事件**显示在横线上方，事件发生时所采取的**动作**显示在横线下方。

- 发送方：

  ![image-20210322104215483](https://static01.imgkr.com/temp/dce3ef2894e34214adfcae40419bea71.png)

  通过 `rdt_send(data)` 事件接收来自较高层的数据，产生一个包含该数据的分组（`make_pkt(data)` 动作），并将分组发送到信道中（`udt_send(packet)`）。

- 接收方：

  ![image-20210322104233538](https://static01.imgkr.com/temp/ae761872ede24d9b9984fb498b9d5754.png)

  rdt 通过 `rdt_rcv(packet)` 事件从底层信道接收一个分组，从分组中取出数据（`extrace(packet, data)`），并将数据上传给较高层（`deliver_data(data)`）。

**缺陷**：没有考虑分组受损或丢失的情况。

#### 经具有比特差错信道的可靠数据传输：rdt 2.0

- 接收方通过**肯定确认**和**否定确认**使得发送方知道哪些内容被正确接收，哪些内容有误需要**重传**。
- **自动重传请求（ARQ）** 协议就是基于这样的重传机制的可靠数据传输协议，其包含三种协议功能来处理比特差错：
  - **差错检测**：需要额外的比特来验证，比如分组检验和字段。
  - **接收方反馈**：需要**肯定确认（ACK）** 和**否定确认（NAK）** 两种报文（一个比特长即可实现）。
  - **重传**：接收方收到有差错的分组时，发送方将重传该分组。

**有限状态机**：

- 发送方：

  ![image-20210322105146046](https://static01.imgkr.com/temp/37f88f4a007d4546a3fcf794f312c78a.png)

  - 收到上层数据（`rdt_send(data)`），产生分组并发送
  - 收到 ACK 分组（`rdt_rcv(rcvpkt) && isACK(rcvpkt)`），返回等待来自上层数据的状态
  - 收到 NAK 分组（`rdt_rcv(rcvpkt) && isNAK(rcvpkt)`），重传上一个分组并等待 ACK 或 NAK 响应

  当发送方处于等待 ACK 或 NAK 的状态时，它**不能**从上层获得更多的数据；因此，除非发送方确信接收方已经正确接收当前分组，它将**不会**发送一个新数据。

- 接收方：

  ![image-20210322105159743](https://static01.imgkr.com/temp/51e0192e267d4ca587bb6a77b41311c7.png)

  当分组到达时，检查检验和，并响应 ACK 或 NAK，检验和错误时（分组受损），接收方将**不**把数据传给上层（`deliver_data(data)`）。

**缺陷**：没有考虑到 **ACK 或 NAK 响应分组会受损**的情况。

**可能的解决办法**：

- 如果 ACK 或 NAK 分组受损，发送方收到后可能不理解含义。所以，定义一个**新型的从发**
- **送方到接收方的分组**，当发送方收到接收方模糊的响应时，便发送该分组给接收方，接收方则重传刚刚的响应分组。但是，这也存在一个问题：这个**新型分组**也会出现差错，使得接收方不知道发送方发送的这个分组，**是 data 的一部分还是要求其重传响应**？因此，接收方也就不知道，这次它应该发送的响应是**针对这个分组（data 的一部分）还是针对上一个分组（要求重传）**；在发送方的视角来说，接收方应该发送的是针对上一个分组的响应。
- 增加足够的检验和比特，使得发送方不仅可以检验差错，还可以纠正差错。对于会产生差错但**不丢失**分组的信道，可以解决问题。
- 当发送方收到含糊不清的 ACK 或 NAK 分组时，**只需重传当前数据分组**即可，即引入**冗余分组**。但冗余分组有一个**根本困难**：因为接收方并不知道发送方是否接收到了上次它的响应（ACK 或 NAK），所以也就不知道这个“新”来的分组，确实是**新**的分组（data 的一部分）还是**重传的分组**？这个困难与第一个方法的困难比较相似，但不完全一样，因为在这个方法中，接收方需要发送的响应**始终是针对当前这个分组的**，与发送方的视角一致，所以可以解决。

#### rdt 2.0 基础上改进的方法：rdt 2.1

- 解决冗余分组方法的一个简单办法是在数据分组中添加一个新字段，让发送方对其数据分组**编号**。在**假设信道不丢失分组**的情况下，**1 比特**序号就足够了，因为它可以让接收方知道发送方**是否正在重传前一个分组**。

- **而 ACK 和 NAK 分组本身并不需要指明它们要确认的分组的序号**，发送方知道所接收到的 ACK 和 NAK 分组是为响应其**最近发送**的数据分组而产生的（无论是不是模糊不清的响应）。只要发送方收到了模糊不清的响应分组或者是 NAK 分组，那它就**重传**上一个分组；如果接收到了 ACK 分组，那么就**发送新分组**。对于接收方而言，如果收到了冗余分组（上次已经成功接收，但是响应的 ACK 分组可能到了接收方时受损）或者正确的分组，前者将其丢弃、后者将其接收，并且发送 ACK 分组（指示发送方应该**发送新分组**了！）；如果收到受损的分组，就发送 NAK 分组（指示发送方**重传**这次的分组！）

**有限状态机**：发送方和接收方都有两套对称的状态，是由于需要区分期待的分组序号是 0 还是 1

- 发送方：

  ![image-20210322202044088](https://static01.imgkr.com/temp/926649f47b434baaa4025861ffc19a8d.png)

  - 收到上层数据（`rdt_send(data)`），产生分组并发送
  - 以等待序号 0 为例：
    - 收到**含糊不清的响应（受损）或者 NAK 分组**（`rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isNAK(rcvpkt))`），重传刚才的分组
    - 收到正确的并且为 ACK 的分组（`rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt)`），等待上层数据**准备发送下一个分组**（状态转移）
  - 等待序号 1 同理

  注意的是，其实发送方不需要**检查序号**，因为**直接视为是对最近分组的响应**。

- 接收方：

  ![image-20210322202728806](https://static01.imgkr.com/temp/ba0a56c0f5934ef9b9f557a0ddd2903d.png)

  - 以等待序号 0 为例：
    - 收到分组，发现出错（`rdt_rcv(rcvpkt) && corrupt(rcvpkt)`），丢弃该分组并发送 NAK 分组
    - 收到分组，未出错，但是序号错误，即发现冗余分组（`rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq1(rcvpkt)`），**丢弃该分组并发送 ACK 分组**
    - 收到分组，未出错，序号正确（`rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq1(rcvpkt)`），接收该分组并发送 ACK 分组，**转移状态至等待序号 1**
  - 等待序号 1 同理

  需要注意的是，当收到失序（冗余）分组时，接收方对发送方返回的是**肯定确认（ACK）**，为的是提醒发送方应该发送下一个分组。

#### rdt 2.0 基础上改进的无 NAK 方法：rdt 2.2

如果不发送 NAK，而是对**上次**正确接收的分组发送一个 ACK，也能实现与 NAK 一样的效果。发送方接收到对同一个分组的两次 ACK（即接收**冗余 ACK**）后，**就知道接收方没有正确接收到跟在被确认两次的分组后面的分组**（即本应该对它响应 NAK 的那个分组）。

> 为什么对上次正确接收的分组发送一个 ACK 也能实现与 NAK 一样的效果呢？
>
> 解释：
>
> - 理解这个疑问，需要考虑三个问题：分析 rdt 2.1，在什么情况下接收方会发送 NAK 分组？发送 NAK 分组是为了什么？发送方收到 ACK 分组时会做什么？
> - 显然，当接收方接收到错误的分组时，才发送 NAK 分组，其目的是提醒发送方**重传这次的分组**。当发送方收到 ACK 分组时，它的下一个动作就是**发送新分组**，即下一个分组。
> - 那么，假设接受方在接收第 N 个分组时发现其受损，向发送方发送对上一次正确接收的第 N-1 个分组的 ACK 响应，当发送方收到这个响应时，就会发送第 N 个分组（第 N-1 个分组的**下一个分组**），实际上的效果就相当于**重传了**这次的（第 N 个）分组。

有限状态机：

- 发送方：

  ![image-20210322204525478](https://static01.imgkr.com/temp/51f7e2287b0f495d9568c18724d343f8.png)

  - 收到上层数据（`rdt_send(data)`），产生分组并发送
  - 以等待序号 0 为例：
    - 收到含糊不清的，或是**对于序号 1** 的 ACK 分组（即对上一个分组的 ACK 响应，对应于 rdt 2.1 中的 NAK 分组）（`rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isACK(rcvpkt, 1))`），**重传该分组**
    - 收到正确的并且是对于序号 0 的 ACK 分组（`rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt, 0)`），等待上层数据**准备发送下一个分组**（状态转移）

- 接收方：

  ![image-20210322204919735](https://static01.imgkr.com/temp/9100cdbce74f4a0f9b7b47cac2b1c176.png)

  - 以等待序号 0 为例：
    - 收到分组，发现出错，或者序号错误（冗余分组）（`rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || has_seq1(rcvpkt))`），**丢弃**并发送**针对序号 1（上一个分组）**的 ACK 分组（`sndpkt=make_pkt(ACK, 1, checksum)`），用以表示当前分组接收有误，需重传。（此时发送方刚转移到等待序号 0 的状态，若收到对于序号 1 的 ACK 分组，就会重传刚刚的分组）
    - 收到分组，未出错，序号正确（`rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && has_seq0(rcvpkt)`），接收并发送针对序号 0（当前分组）的 ACK 分组（`sndpkt=make_pkt(ACK, 0, checksum)`），**转移状态至等待序号 1**

#### 经具有比特差错的丢包信道的可靠传输协议：rdt 3.0

- rdt 2.2 中已经运用到的技术：检验和、序号、ACK 分组和重传，但是还是无法处理**丢包**的问题，在此，我们让**发送方**承担起**检测和恢复丢包**的任务。
- 假定发送方传输了一个数据分组，该分组、或者接收方对该分组的 ACK 发生了丢失。在这两种情况下，发送方都收不到应当到来的 ACK 响应。如果发送方**愿意等待足够长的事件以便确定分组已丢失**，则只需**重传**该分组即可。发送方至少应该等待**一个 RTT** 加上接收方处理一个分组的时间。
- 注意到，即使该分组和 ACK 都没有丢失，但是如果经历了特别大的时延，发送方都可能重传该分组，这就是**冗余数据分组**，在 rdt 2.2 中已能够处理。对发送方而言，不需要区分是分组丢失了，还是 ACK 丢失了，还是延时过大，它只需重传分组即可。
- 因此，需要一个**倒计数定时器**，在一个给定的时间量过期后，中断发送方。发送方需要能够做到：① 每次发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器；② 响应定时器中断（采取适当的动作）；③ 终止定时器。

**有限状态机**：

- 发送方：

  ![image-20210322211308707](https://static01.imgkr.com/temp/8b0690a7eedd4b0292680b017678a9ea.png)

  - 收到上层数据（`rdt_send(data)`），产生分组并发送，启动计时器（`start_timer`）
  - 以等待序号 0 为例：
    - 收到含糊不清的，或是**对于序号 1** 的 ACK 分组（即对上一个分组的 ACK 响应，对应于 rdt 2.1 中的 NAK 分组）（`rdt_rcv(rcvpkt) && (corrupt(rcvpkt) || isACK(rcvpkt, 1))`），**无动作**
    - 超时（`timeout`），重传该分组，**启动计时器**（`start_timer`）
    - 收到正确的并且是对于序号 0 的 ACK 分组（`rdt_rcv(rcvpkt) && notcorrupt(rcvpkt) && isACK(rcvpkt, 0)`），**停止计时器**（`stop_timer`），等待上层数据**准备发送下一个分组**（状态转移）

  需要注意，与 rdt 2.2 中不同的是，3.0 中发送方在接收到错误的或序号不正确的响应分组时，**不采取任何动作**。**只有当超时事件发生时**，才重传。并且，当发送方已确认接收方正确接收到分组了（收到正确的 ACK），才停止计时器。

  > 为什么接收到错误或不正确序号的分组时，发送方不采取任何动作呢？
  >
  > 当接收到错误的分组时，发送方可重传也可以不重传，不影响。
  >
  > 但是，当接收到不正确的序号为 n 的分组时，代表：**对分组 n 的 ACK 之前已被接收**，这次到来的是对**因超时重传**的分组 n 的 ACK。因为之前分组 n 的 ACK 已被接收，说明**当前分组 n + 1 也已被发送**，即信道中已经存在一个分组 n + 1，如果这次收到失序的 ACK（对于分组 n 的 ACK）后再次重传当前分组（分组 n + 1），就会导致**信道中存在两个相同的分组（n + 1）**，并且该错误会一直传递下去，占用信道。
  >
  > ![image-20210323110622868](https://static01.imgkr.com/temp/f05f7de5bbe345dbb5f2ac8f81547948.png)
  >
  > 可以看到，此图中因为一次超时，使得接收方对于分组 0 的 ACK 超时到达，**在此之前发送方已经重传了一次分组 0**，如果在收到对于**重传**的分组 0 的 ACK（此时认为是失序的响应分组）时，发送方再次重传，那么就会导致信道中始终有两个重复的分组在传输。

- 接收方：

  与 rdt 2.2 一样，因为计时器的约束仅针对发送方。

总结：可靠数据传输协议中使用到的技术：检验和、序号、定时器、肯定和否定确认分组、重传等技术。

### 流水线可靠数据传输协议

rdt 3.0 虽然功能正确，但是性能一般，因为它是一个**停等**协议：发送方在等待确认时，不会发送新分组，也就是说从一个分组被发送到下一个分组被发送中间间隔了很长的时间。

> 假设信道速率为 R = 1Gbps，分组 L = 8000 比特，则发送一个分组实际所需时间：
>
> $$t_{trans}=\frac{L}{R}=\frac{8000bit/pkt}{10^9bit/s}=8\mu s/pkt$$
>
> 假设 $RTT=30ms$，那么该分组的最后 1 比特在时刻 $t=RTT/2+L/R=15.008ms$ 时到达接收方。假设 ACK 分组很小，接收方一旦收到最后一个比特后立刻发送 ACK，则 ACK 在时刻 $t=RTT+L/R=30.008ms$ 时到达发送方。
>
> 在 $30.008ms$ 内，发送方的发送实际只用了 $0.008ms$，那么该停等协议的**利用率**为：
>
> $$U_{sender}=\frac{L/R}{RTT+L/R}=\frac{0.008}{30.008}=0.00027$$

如果发送方可以在等待确认之前发送多个报文，那么利用率也可以提高，这就是**流水线**技术，其对可靠数据传输的影响：

- **必须增加序号范围**，每个传输中的分组必须有一个唯一的序号。
- **发送方和接收方也许不得不缓存多个分组**。发送方最低限度应当能够缓存那些**已发送但没有被确认**的分组，接收方也许也需要缓存那些已被正确接收的分组。
- 所需序号的范围和对缓存的要求取决于数据传输协议如何处理丢失、损坏和延时过大的分组。差错恢复的两种基本方法：**回退 N 步（GBN）和选择重传（SR）**

#### 回退 N 步

- 在 GBN 协议中，允许发送方发送多个分组而不需等待确认，但它也受限于**在流水线中未确认的分组不能超过某个最大允许数 N**。

- 为了确定发送方的序号范围，将**基序号（base）**定义为**最早未确认分组**的序号，将**下一个序号（nextseqnum）**定义为**最小未使用序号（即下一个待发送分组的序号）**，则可将序号范围分割成 4 段。

  ![image-20210322215032556](https://static01.imgkr.com/temp/afeb487a96094dd2b1d42c4788053c84.png)

  - [1, base - 1]：已经发送并被确认的分组
  - [base, nextseqnum - 1]：已发送但未被确认的分组
  - [nextseqnum, base + N - 1]：能用于那些要被立即发送的分组
  - [base + N, end]：直到下一个未被确认的分组被确认之前不能使用的分组

- N 常被称为**窗口长度**，所以 GBN 协议也被称为**滑动窗口协议**。

**基于 ACK、无 NAK 的 GBN 协议的扩展 FSM**：

- 发送方：

  ![image-20210322215235943](https://static01.imgkr.com/temp/f82fa05c6eba49ad8df104259830e52f.png)

  - 初始化，`base = nextseqnum = 1`

  - 收到上层数据（`rdt_send(data)`），如果窗口未满（`nextseqnum < base + N`），**缓存**（`sndpkt[nextseqnum]`）并发送该分组，如果**之前发送的分组都已经被确认**（`base == nextseqnum`），启动计时器，下一个序号后移（`nextseqnum++`）；如果窗口已满，拒绝上层的数据（隐式地指示上层该窗口已满，等会再试）（`refuse_data(data)`）

  - 超时，重启计时器，**重传所有已发送但未被确认的分组**（`udt_send(sndpkt[base ... nextseqnum-1])`）（**回退 N 步**，使用缓存）

  - 收到正确的 ACK（`rdt_rcv(rcvpkt) && notcorrupt(rcvpkt)`），获得**最新被确认的分组序号**（`base=getacknum(rcvpkt)+1`），如果没有已发送但未被确认的分组（`base == nextseqnum`），**停止计时器（发送新分组时会再次启动）**，否则重新启动计时器（**对应于下一个已发送但未被确认的分组**）

    注意到，获得最新被确认的分组序号并赋值给 base，实际上是 base 右移。这里采用了**累计确认**的方式，**当接收到对序号为 n 的分组的 ACK 时，表明接收方已正确接收到序号为 n 及之前的所有分组**

  - 收到错误的响应，**不采取任何动作**

  发送方仅使用一个计时器，它可被当作是**最早的已发送但未被确认的分组**所使用的计时器。如果收到一个 ACK，但仍有已发送但未被确认的分组，则计时器被重新启动，否则停止计时器。

- 接收方：

  ![image-20210322220636742](https://static01.imgkr.com/temp/395d2dd0df5542d08fc96676515c4112.png)

  - 初始化，`expectedseqnum=1; sndpkt=make_pkt(0, ACK, checksum)`，设置**期待的分组序号**为 1，注意到报文中的序号初始为 0，这里与 rdt 2.2 类似，如果序号为 1 的分组丢失或者对其的 ACK 丢失，那么响应对于序号 0 的 ACK 使得发送方重传序号为 1 的分组（`base=getacknum(rcvpkt)+1` 会使得 base 为 1，而 nextseqnum 也为 1，`base==nextseqnum` 重传时会重启计时器）
  - 收到分组，分组正确并且**是所期待的那个分组**（`hasseqnum(rcvpkt, expectedseqnum)`）（说明**按序**到达了），接收该分组并且响应对于 exceptedseqnum 的 ACK 分组（`sndpkt=make_pkt(expectedseqnum, ACK, checksum)`），exceptedseqnum 右移（`expectedseqnum++`）
  - 其他（失序）情况（默认），**丢弃到达的（失序）分组**，并发送对**最近按序接收到的分组**的 ACK 响应（`udt_send(sndpkt)`），**其中 sndpkt 是缓存的最近按序接收到的分组**

  > ① 为什么接收方丢弃所有失序分组？
  >
  > 假定现在期待接收分组 n，而分组 n + 1 到达了。因为数据必须按序交付，接收方可能想缓存分组 n + 1，然后在它收到并交付分组 n 后，再将分组 n + 1 交付到上层。然而，只要之后分组 n 重传到达并被接收方交付，则分组 n 及分组 n + 1 **最终都会根据 GBN 规则而被重传（序号范围 [base, nextseqnum-1] 都会被重传）**。所以，之前缓存分组 n + 1 的这个动作是**多余**的，接收方只需丢弃分组 n + 1 即可。
  >
  > **这种方法使得接收方不需要缓存任何失序分组，只需要维护下一个按序接收的分组的序号（期待的分组序号）**。
  >
  > ② 为什么收到失序分组时，接收方一定要对最近按序接收到的分组发送 ACK 响应呢？
  >
  > 假设窗口大小为4，发送方连续发送1, 2, 3, 4号帧，接收方全部正确接收，但返回的确认帧却**全部丢失**。当发送方超时重传1, 2, 3, 4号帧时，接收方会全部丢弃（接收方正等待接收5号帧），**如果不对4号帧进行再确认，发送方会一直重传1, 2, 3, 4号帧**。

GBN 协议中也有一个缺点，即当丢弃一个正确接收的分组时，随后对该分组的重传也许会丢失和出错，因此甚至需要更多的重传。

总结：GBN 协议中使用到的技术：序号、累计确认、定时器、肯定和否定确认分组、检验和以及超时/重传操作。

#### 选择重传

- GBN 协议潜在地允许发送方用多个分组填充流水线，因此避免了停等协议中所提到的信道利用率问题。然而，当窗口长度和带宽时延积都很大时，GBN 也会有性能问题。**单个分组的差错就能够引起 GBN 重传大量分组，许多分组根本没有必要重传**。

- 而选择重传（SR）协议通过让发送方**仅重传那些它怀疑在接收方出错（即受损或丢失）的分组**而避免了不必要的重传。这种个别的、按需的重传要求接收方**逐个**确认正确接收的分组。

- SR 也用窗口长度 N 来限制流水线中未完成、未被确认的分组数量，在接收方也维护一个窗口。发送方可以确认在**基序号后某些分组的 ACK**。

  ![image-20210323145047810](https://static01.imgkr.com/temp/d82be16804ff4f9696db46cb44d3c2a4.png)

- SR 接收方将确认一个正确接收的分组**而不管其是否按序**。失序的分组（`序号 > rcv_base`)将被缓存直到所有丢失分组（即序号更小的分组皆被收到为止）

**事件与动作**：

- 发送方：

  - 从上层收到数据：检查窗口是否已满，如果未满，发送分组；如果已满，同 GBN，要么缓存数据，要么将其返回给上层以便之后传输。
  - 超时，定时器再次被用来防止丢失分组。但是，在 SR 中**每个分组都有自己的定时器**（在 GBN 中所有分组只有一个定时器，用于指示最早的已发送但未被确认的分组），因为**超时发生后只能发送一个分组**（而不是重传所有分组）。
  - 收到 ACK：如果该分组序号在窗口内，则发送方将其标记为已接收；如果**分组序号 `== send_base`**，说明 send_base 可以右移了，如同 GBN 中 base 的右移，不过 GBN 中只移动一格，而在 SR 中，可能在 send_base **后面有些分组已经被确认**，所以这里的移动指**向右移动到最近的未被确认的分组处**。**如果窗口移动了，并且现窗口内有未发送的分组**，那么发送这些分组。

- 接收方：

  - 序号在 `[rcv_base, rcv_base + N - 1]` 内的分组被正确接收：返回一个 ACK 给发送方。如果该分组以前没收到过，则缓存该分组。如果该**分组序号 `== rcv_base`**，说明 rcv_base 可以右移了，如同 GBN 中 expectedseqnum 的右移，将**起始于 rcv_base** 的**连续的已被接收**的分组一起交付给上层，并将 rcv_base **右移到最近的还未接收的分组处**。

    > 举例：send_base = 2，N = 4
    >
    > 发送方的视角：序号 2，3，4，5 的分组都已发送，但只有 3，4，5 被确认
    >
    > 接收方的视角：序号 3，4，5 的分组都已接收到并响应 ACK
    >
    > 此时，显然是分组 2 丢失。对发送方而言，如果序号为 2 的分组不被确认，那么由于窗口限制，它也不能发送后面的分组；对接收方而言，如果分组 2 再不到达，它也无法将 3，4，5 分组向上交付。
    >
    > 如果发送方再次发送分组 2，并且接收方成功接收并响应，发送方也接收到了该响应。那么，send_base 右移到 6，rcv_base 右移到 6，分组 2，3，4，5 都被接收方向上交付。

  - 序号在 `[rcv_base - N, rcv_base - 1]` 内的分组被正确接收：此时说明**之前的 ACK 没有到达发送方（或受损）**，在发送方的视角而言 rcv_base 之前还有分组未被确认，**即 `send_base < rcv_base` 的情况**。此时必须产生一个 ACK，再次告诉发送方已经收到该分组，从而使发送方的 send_base 右移。

  - 其他情况，忽略该分组。

和 GBN 类似，SR 的接收方也必须重新确认（而不是忽略）已收到过的分组，尤其是小于接收窗口基序号的分组。因为对发送方而言，它并不知道接收方已成功接收，所以它将一直重传；如果接收方不重新确认，那么发送方将永远重传下去。这种现象的原因就在于，**发送方和接收方视角中的窗口并不总是一致！**

在**有限序号范围**的情况下，如果发送方和接收方的窗口不同步，那么可能会出现问题。因为有限序号情况下，序号的计算是模运算，例如 `0 1 2 3 0 1 2 3` 一直循环下去，如果窗口不一致，**可能发送方还在重传上一轮的 0，而接收方确认的却是新一轮的 0**（当窗口长度为 3，第一轮的 0 1 2 的 ACK 都丢失时就会出现这种情况），就会导致错误，即**接收方无法区分是一个新分组还是一次重传**。当**窗口长度比序号空间小 1 时协议无法工作**，而经证明，**窗口长度必须小于或等于序号空间大小的一半**（考虑极限情况）。

### 总结

**可靠数据传输机制中用到的技术**：

- 检验和，用于检测比特错误
- 定时器，用于超时/重传一个分组
- 序号，使接收方检测出丢失的分组或冗余分组
- 肯定确认和否定确认，接收方对于发送方的响应
- 窗口、流水线，允许发送方一次发送多个分组，提高信道利用率

**其他讨论**：虽然逐步深入地讨论了如此多的情况，但是其实还是比较理想化。还有一个遗留假设未解决：**分组在信道中可能会发生重新排序**。对于这种情况，信道可被看成基本上是在**缓存分组，并在将来任意时刻自然地释放出这些分组**。由于序号可以被重复使用，那么需要避免出现这样的冗余分组。解决办法就是：**直到发送方可以确信任何先前发送的序号为 x 的分组都不在网络中，确保序号 x 不被重新使用**，可以通过**假定一个分组在网络中的存活时间不会超过某个固定最大时间量**来做到这一点。

## 3.5 面向连接的运输：TCP

- TCP 的实现依赖于前一节中的基本原理：差错检测、重传、累计确认、定时器以及用于序号和确认号的首部字段。

- TCP 是**面向连接**的，两个应用进程在通信之前，必须经过**三次握手**，即发送某些预备报文段。

- TCP 的连接是一条**逻辑**连接，其共同状态保留在两个通信端系统的 TCP 程序中。

- TCP 是**全双工**服务，并且总是**点对点**的。

- 当建立起 TCP 连接，两个进程就可以互相发送数据。当数据**通过套接字**时，就由 TCP 控制。TCP 将这些数据引导到该链接的**发送缓存**，发送缓存是三次握手期间设置的缓存之一。TCP 不时地从该缓存中取出数据传递到网络层。TCP 可从缓存中取出并放入报文段中的数据数量受限于**最大报文段长度（MSS）**；而 MSS 通常根据最初确定的由本地发送主机发送的**最大链路层帧长度（即最大传输单元 MTU）**来设置。设置该 MSS 要保证一个 TCP 报文段（封装在一个 IP 数据报中）加上 TCP/IP 首部长度（通常为 **40 字节**）将适合单个链路层帧。

  > 以太网和 PPP 链路层协议都具有 1500 字节的 MTU，因此 MSS 的典型值为 1460 字节。
  >
  > 注意到 MSS 是指报文段里**应用层数据**的最大长度，而不包括 TCP 和 IP 的首部。

- 所以，TCP 连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。但**网络层并不为连接分配缓存和变量**（各层独立）。

### TCP 报文段结构

首部一般是 20 字节，而 UDP 是 8 字节。

![image-20210323154937626](https://static01.imgkr.com/temp/252672760c3c4d02b3622c022f47c750.png)

- 序号和确认号用于实现可靠数据传输服务

  - 一个报文段的序号是该报文段**首字节**的字节流编号
  - 确认号是接收方**期望**从发送方收到的**下一个字节**的序号

  TCP 采用**累计确认**，只确认该流中至**第一个丢失字节**位止的字节。比如主机 A 收到了 0\~535、900\~1000的报文段，但它向发送方发的下一个报文段将在确认号字段中填写 **536**。收到失序报文段的行为由实现 TCP 的编程人员决定，他可以选择立即丢弃，也可以选择缓存。

  一条 TCP 连接的双方均可**随机**地选择初始序号，这样可以减少将那些仍在网络中存在的来自两台主机之间先前已终止的连接的报文段，被误认为是后来这两台主机之间新建连接而产生的有效报文段的可能性。

  > 举例：Telnet（应用层协议，运行在 TCP 之上）远程登陆![image-20210323160033807](https://static01.imgkr.com/temp/9ba35d532f0a4c869631a91e536ea666.png)
  >
  > - host --> server: seq, ack
  > - server --> host: ack, seq + 1
  > - host --> server: seq + 1, ack + 1

- 接收窗口用于**流量控制**，表示接收方愿意接受的字节数量

- 标志字段

  - ACK：确认分组
  - RST、SYN、FIN：用于连接建立和拆除
  - CWR、ECE：拥塞通告
  - PSH：被置位时表示接收方应立即将数据交给上层
  - URG：用于指示报文段中存在着被发送端的上层实体置为**紧急**的数据，紧急数据的最后一个字节由 16 比特的**紧急数据指针字段**指出

  在实践中，PSH、URG 并没有被使用

### 往返时间的估计与超时

TCP 采用超时/重传机制来处理报文段的丢失，所以必须设置超时间隔，它必须大于 RTT，所以需要估计 RTT。

- 大多数 TCP 的实现仅在某个时刻做一次 SampleRTT （样本 RTT）的测量，而不是为每个发送的报文段都进行测量。即在任意时刻，**仅为一个**已发送但目前尚未被确认的报文段估计 SampleRTT，从而产生一个接近每个 RTT 的新 SampleRTT。
- TCP **不为**已被重传的报文段计算 SampleRTT；它仅为传输一次的报文段测量。

一旦获得一个新的 SampleRTT 时，TCP 就会更新估计的 EstimatedRTT：

$$EstimatedRTT = (1-\alpha)*EstimatedRTT+\alpha *SampleRTT$$

注：$\alpha$ 的推荐值为 0.125。

所以，这个加权平均对**最近的样本**赋予的权值要**大于**对旧样本赋予的权值。

测量 RTT 的变化也有价值，所以 RTT 偏差 DevRTT 用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度：

$$DevRTT=(1-\beta)*DevRTT+\beta *|SampleRTT-EstimatedRTT|$$

注：$\beta$ 的推荐值为 0.25。

如果 SampleRTT 的波动很小，那么 DevRTT 就会很小；反之更大。

**设置 TCP 超时间隔**：

- 首先，应大于等于 EstimatedRTT，但不能大太多
- 所以，将间隔设置为 EstimatedRTT 加上一定的**余量**，当 SampleRTT 波动较大时，余量较大；反之较小

所以：

$$TimeoutInterval=EstimatedRTT+4*DevRTT$$

注：对 TimeoutInterval 推荐的初始值为 1 秒。

当超时发生后，TimeoutInterval **加倍**；否则，更新 EstimatedRTT 并计算新的 TimeoutInterval。这种修改提供了一个**形式受限**的拥塞控制，因为超时事件的发生很可能是由于网络堵塞，在拥塞的时候，如果源持续重传分组，会使拥塞更加严重。所以 TCP 使每次发送方的重传都是经过**越来越长**的时间间隔后进行。

### 可靠数据传输

TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是**无损坏、无间隙、非冗余和按序**的数据流。

**TCP 发送方高度简化的描述：只用超时来恢复报文段的丢失**：

```cpp
/* 假设发送方不受 TCP 流量和拥塞控制的限制，来自上层的数据的长度小于 MSS，且数据传送只在一个方向进行 */

NextSeqNum = InitialSeqNumber;
SendBase = InitialSeqNumber;

loop (true) {
    switch (事件)
        事件：从上层接收到数据 e
        	生成具有序号 NextSeqNum 的 TCP 报文段
        	if (定时器当前没有运行) 
                启动定时器
            向 IP 传递报文段
            NextSeqNum = NextSeqNum + length(e);
            break;
    	事件：定时器超时
            重传具有最小序号但仍未应答的报文段
            启动定时器
            break;
    	事件：收到 ACK，具有 ACK 字段值 y
            if (y > sendBase) {
                sendBase = y; // 累计确认
                if (当前仍无任何应答报文段) 
                    启动定时器
            }
    		break;
}
```

注意到，TCP 采用累计确认，所以 y 确认了字节编号在 y 及 y 之前的所有字节都已被收到。

**快速重传**：

TCP 接收方：

- 收到期望序号的报文段，所有期望序号及其以前的数据都已被确认：先不发 ACK（延迟等待），对下一个应按序到达的报文段最多等待 500ms；如果时间间隔内未到达，则发送一个 ACK
- 收到期望序号的报文段，并且下一个按序到达的报文段等待 ACK（即连续收到两个按序到达的报文段）：立即发送**单个** ACK，直接**累计确认**这两个报文段
- 比期望序号大的报文段到达：立即发送冗余 ACK，指示**下一个期待字节的序号**
- 能部分或完全填充接收数据**间隔**的报文段到达：倘若该报文段序号等于期望序号（**起使于间隔的低端**），则立即发送 ACK

如果一个报文段丢失，很有可能引起许多接收方的冗余 ACK。如果发送方接收到对相同数据的**三个冗余 ACK**，就**认为跟在这个已被确认过三次的报文段之后的报文段已经丢失**。于是，TCP 执行**快速重传**，而不等待定时器过期。

```cpp
/* 加入快速重传的发送方 */

事件：收到 ACK，具有 ACK 字段值 y
    if (y > sendBase) {
        sendBase = y;
        if (当前仍无任何应答报文) 
            启动定时器
    }
	else {
        // 收到冗余 ACK
        对 y 收到的冗余 ACK 数 + 1
        if (对 y 收到的冗余 ACK 数 == 3) 
            // 执行快速重传
            重新发送具有序号 y 的报文段
    }
```

**TCP 与 GBN、SR 的比较**：

- TCP 发送方仅需维持已发送过但未被确认的字节的最小序号（sendBase）和下一个要发送的字节的序号（nextSeqNum），并且许多实现使用单一定时器，像 GBN
- 许多 TCP 的实现会将正确接收但失序的报文段缓存起来，像 SR
- TCP 超时事件发生时，至多重传一个分组（如果该分组之后分组的 ACK 到达，就直接累计确认，不进行重传），而 GBN 可能会重传 [base, nextseqnum - 1] 的所有分组

对 TCP 提出的一种修改意见是**选择确认**，它允许 TCP 接收方**有选择地确认失序报文段**，而不是累计地确认**最后一个**正确接收的**有序**报文段。当该机制与**选择重传**机制结合起来使用时（即**跳过重传那些已被接收方选择性地确认过的报文**），TCP 更像 SR 协议。因此，TCP 的差错恢复机制最好被分类为 GBN 与 SR 的混合体。

> TCP 协议一般是通过 GBN 方式的变种来实现传输可靠性的，而当通信双方支持选择重传 SACK 选项时，TCP 协议就会改为使用 Selective Repeat 方式来实现传输可靠性。
>
> 可以认为，**选择确认是选择重传的基础**。在 SR 的讨论中，也可以看到发送方实际上确实进行了选择确认。

### 流量控制

- 如果某应用程序读取数据时相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。

- TCP 提供了流量控制服务，它是一个**速度匹配服务**，即发送方的发送速率与接收方应用程序的读取速率相匹配。而发送方因为 IP 网络的拥塞而被抑制则是**拥塞控制**。

  > 流量控制：由接收方的接收缓存影响
  >
  > 拥塞控制：由网络阻塞而导致的丢包影响

- TCP 通过让**发送方**维护一个称为**接收窗口**的变量来提供流量控制。即接收窗口用于给发送方一个指示——**该接收方还有多少可用的缓存空间**。因为 TCP 是全双工通信，所以两端的发送方各自维护一个接收窗口。

定义如下变量：

- RcvBuffer：接收缓存的大小
- LastByteRead：接收主机的应用程序**从缓存中读出的数据流的最后一个字节**的编号
- LastByteRcvd：从网络中到达并且**已放入接收主机的接收缓存中的数据流的最后一个字节**的编号

因为缓存不能溢出，所以：

$$LastByteRcvd - LastByteRead \le RcvBuffer$$

接收窗口用 rwnd 表示，根据缓存可用空间的数量来设置：

$$rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]$$

![image-20210323214750560](https://static01.imgkr.com/temp/ff30df0dab0c4e299f3a60d7707cb34e.png)

- 接收主机通过把当前的 rwnd 值放入它给发送主机的报文段的**接收窗口**字段中，以通知发送方它在该连接的缓存中还有多少可用空间。初始时，设定 rwnd = RcvBuffer。

- 发送主机轮流跟踪两个变量，LastByteSent 和 LastByteAcked。这两个变量的差就是**发送方已发送但未被确认**的数据量。通过将其控制在值 rwnd 以内，就不会溢出：

  $$LastByteSent - LastByteAcked \le rwnd$$

- 但存在一个问题：当 rwnd = 0 时，发送方收到缓存已满的通告，不会继续发送分组。假设接收方也没有数据要发给发送方，此时，当接收方的缓存清空时，它也**不会通知**发送方！所以，TCP 规定：当接收方的接收窗口为 0 时，发送方**继续发送**只有**一个字节**数据的报文段。这些报文段最终会被接收方接收。最终缓存将开始清空，并且确认报文里将包含一个非 0 的 rwnd 值。

### TCP 连接管理

#### 建立连接：三次握手

① 用户发送一个特殊报文段，置 SYN 比特为 1，不包含应用层信息。所以这个报文段也被称为 **SYN 报文段**。用户会随机地选择一个初始序号（client_isn），并将此序号放置于该起使的 TCP SYN 报文段的序号字段中。

② 服务器接收到用户发送的 SYN 报文段，**为该 TCP 连接分配 TCP 缓存和变量**（半连接状态），并向该用户 TCP 发送允许连接的报文段，SYN 比特被置为 1，不包含应用层信息。该报文段的**确认号**字段设为 **client_isn + 1**，**向用户表明他的 SYN 报文段已被接收**，然后服务器设置一个随机的初始序号（server_isn）。该允许连接的报文段被称为 **SYN ACK 报文段**。

③ 用户收到 SYN ACK 报文段后，**为该连接分配缓存和变量**。客户需要向服务器发送另外一个报文段，设置**确认号**为 **server_isn + 1**，**向服务器表明它的 SYN ACK 报文段已被接收**。因为连接已经建立，所以置 SYN 比特为 0。**该报文段可以携带客户到服务器的数据**。

![image-20210323220532568](https://static01.imgkr.com/temp/86c46f401e014c2ba542501313a61527.png)

#### 终止连接：四次挥手

TCP 连接中的**任意一方**都能终止该连接。

① 用户向服务器进程发送一个特殊的 TCP 报文段，置 FIN 比特为 1。

② 服务器接收到该报文段后，向用户发送一个确认报文段。

③ 然后，服务器发送它自己的终止报文段，置 FIN 比特为 1。

④ 最后，该用户对服务器的终止报文段进行确认。此时用户并不立刻关闭连接，而是等待一段时间（TIME_WAIT 状态），因为可能 ACK 会丢失，需要用户重传最后的确认报文。

![image-20210323220812457](https://static01.imgkr.com/temp/25bece78993743b48d6153e8f10e48f5.png)

**客户 TCP 状态序列**：

![image-20210323221110260](https://static01.imgkr.com/temp/7b67f52188b645c8a116f8c497a7b4e1.png)

**服务器 TCP 状态序列**：

![image-20210323221441937](https://static01.imgkr.com/temp/af08731ce74744c494ae39650aceb71d.png)

**特殊情况**：端口号或源 IP 地址与套接字不匹配的情况。当一台主机接收了目的端口 80 的一个 TCP SYN 分组，但该主机在端口 80 不接受连接，则该主机向源发送一个**特殊重置报文段**，将 RST 标志位置为 1。当一台主机接收到一个 UDP 分组，但目标端口与 UDP 套接字不匹配，则该主机发送一个特殊的 ICMP 数据报。

## 3.6 拥塞控制原理

丢包是当网络变得拥塞时由于路由器缓存溢出引起的。分组重传因此作为网络拥塞的**征兆**来对待，但是却**无法处理导致网络拥塞的原因**。所以需要一些机制以在面临网络拥塞时**遏制发送方**。

### 拥塞原因与代价

#### 情况 1: 两个发送方和一台具有无穷大缓存的路由器

![image-20210324154328246](https://static01.imgkr.com/temp/0c195a7b629e4c99b9c909970cb97a64.png)

假设主机 A 和 B 向路由器提供流量的速率是 $\lambda_{in}$ 字节/秒，数据在一段容量为 R 的共享式输出链路上传输，假设路由器有无限大的缓存空间。
显然，每连接的吞吐量为：$\min\{\frac{R}{2}, \lambda_{in}\}$。然而，当发送速率接近 $\frac{R}{2}$ 时，平均**时延**就会很大（流量强度接近 1）。虽然从吞吐量看，运行在总吞吐量接近 R 的状态也许是一个理想状态，但从时延角度看，却远不是一个理想状态。

![image-20210324154343500](https://static01.imgkr.com/temp/dcc5b5a54d43438588bc18bdce22ab57.png)

在这种极端理想化的情况中，我们发现了拥塞网络的一种代价：**当分组的到达速率接近链路容量时，分组经历巨大的排队时延**。

#### 情况 2: 两个发送方和一台具有有限缓存的路由器

![image-20210324154421319](https://static01.imgkr.com/temp/dccfff07626f4ba9b2d7bf56d02cd1e3.png)

在情况 1 的基础上，假定路由器的容量有限。如果一个包含运输层报文段的分组在路由器中被丢弃，那么它终将被发送方重传，所以发送速率更应受到限制。用 $\lambda_{in}^{'}$ 表示运输层向网络中发送报文段（包含初始数据和**重传数据**）的速率，其也被称为网络的**供给载荷**。

- 假设仅当缓存空闲时才发送一个分组：那么就和情况 1 一样，平均主机发送速率不能超过 $\frac{R}{2}$

- 假设发送方**仅当在确定了一个分组已经丢失时才重传**：当供给载荷等于 $\frac{R}{2}$ 时，假设每两个分组中就有一个需要重传，则平均而言传输的分组中有 $\frac{2}{3}$ 是初始数据，$\frac{1}{3}$ 是重传数据。所以在发送的 0.5R 单位数据中，平均 0.333R 是初始数据，而 0.166R 是重传数据。

  ![image-20210324154438221](https://static01.imgkr.com/temp/6bfd34e616264ca8a7c381d9ebe9c2a1.png)

  从中我们发现了拥塞网络的另一种代价：**发送方必须执行重传以补偿因为缓存溢出而丢失的分组**。

- 假设发送方也许会**提前发生超时并重传在队列中已被推迟但还未丢失的分组**：在这种情况下，初始数据分组和重传分组**都可能到达接收方**，但它只需一份，所以有一份分组将被丢弃，而**路由器转发这个被丢弃的分组实际上是在做无用功，它本能够用于转发另一个分组**。假设每个分组被路由器平均转发两次，那么当供给载荷接近 $\frac{R}{2}$ 时，其吞吐量仅渐进 $\frac{R}{2}$。所以，拥塞网络的另一种代价就是：**发送方在遇到大时延时所进行的*不必要*重传会引起路由器利用其链路带宽来转发*不必要*的分组副本**。

  ![image-20210324154448219](https://static01.imgkr.com/temp/40c765acd4204c9299a3f40798446bfd.png)

#### 情况 3: 4 个发送方和具有有限缓存的多台路由器及多跳路径

![image-20210324154508539](https://static01.imgkr.com/temp/b07d8f18d72d4d7db830fdb4b880cca7.png)

假设四个发送方的发送速率都是 $\lambda_{in}$。

- 对极小的 $\lambda_{in}$ 值，路由器缓存的溢出很少，吞吐量大致接近供给载荷。
- 对**稍大**的 $\lambda_{in}$ 值，对应的吞吐量**更大**，溢出仍然很少。
- 但当 $\lambda_{in}$ 值**很大**时，例如到达路由器 R2 的 A-C 的流量会被 B-D 的流量所**挤占**，因而 A-C 连接在 R2 上的吞吐量**趋近于 0**（即被 R2 丢弃），并且 A-C 连接在 R1 上的流量被**浪费**了。即在大流量的情况下，每当有一个路由器在**第二跳**路由器上被丢弃时，第一跳路由器所做的将分组转发到第二跳路由器的工作就是**无用功**。所以，第一跳路由器所使用的将分组转发到第二跳路由器的传输容量用来传送不同的分组可能更有效益，比如，当选择一个分组发送时，路由器最好优先考虑**那些已经历过一定数量的上游路由器的分组**。
  所以，由于拥塞而丢弃分组的另一种代价是：**当一个分组沿着一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了**。

![image-20210324160616088](https://static01.imgkr.com/temp/6fe1ba4277bc4456a95d608a3faf2dcf.png)

### 拥塞控制方法

- **端到端拥塞控制**：（默认情况下）网络层不会为运输层拥塞控制提供显式支持。TCP 通过超时或 3 次冗余确认认为网络拥塞，此时会相应地减少其窗口长度。
- **网络辅助的拥塞控制**：路由器向发送方提供关于网络中拥塞状态的显式反馈信息，可以简单地使用一个比特来指示。例如，在 ATM 可用比特率（ABR）拥塞控制中，路由器显式地通知发送方它能在输出链路上支持的最大主机发送速率。
  两种方式：① **阻塞分组**：直接由路由器通知发送方；② 路由器**标记或更新**由发送方流向接收方的分组中的某个字段来指示拥塞的产生，一旦收到一个被标记的分组时，接收方就会向发送方通知该网络拥塞指示，这种形式的通知**至少要经过一个 RTT**。

## 3.7 TCP 拥塞控制

因为 TCP 使用端到端拥塞控制，所以它采用的方式是让**每一个发送方根据感知到的网络拥塞程度来限制其能向连接发送流量的速率**。

- 发送方如何限制其向连接发送流量的速率？
  TCP 发送方跟踪一个额外的变量，即拥塞窗口，拥 cwnd 表示，则：
  $$LastByteSent-LastByteAcked\le \min\{cwnd, rwnd\}$$
  上面的约束限制了发送方中未被确认的数据量，因此间接地限制了发送方的发送速率，假设接受窗口很大，则发送方的发送速率最大为 $$cwnd/RTT$$ 字节/秒，即一个往返时间内发送方只能发送 cwnd 个字节的数据，直到它接收到对数据的确认报文。
- 发送方如何感知网络拥塞？
  将 TCP 发送方的丢包事件定义为：要么出现**超时**，要么收到来自接收方的 **3 个冗余 ACK**。
- 发送方如何调节其发送速率？
  当网络没有拥塞时，发送方收到对以前未被确认的报文段的确认，它认为网络正常，并**使用确认来增加窗口的长度**（及其传输速率）。所以，当确认以相当慢的速率到达，那么窗口增加的速率也很慢；反之，其增加的速率也很快（保持同步）。因为 TCP 使用确认来触发增大它的拥塞窗口长度，所以 TCP 被说成是**自计时**的。

> 为什么发送方要增加发送速率？
> 因为可能没有充分利用网络的带宽，TCP 发送方的目标是**尽量以高的速率而不使网络拥塞**。
> 如果网络拥塞，发送方会减少其发送速率。在经过一个超时事件或者对于同一个分组的四个确认时，发送方会通过 **TCP 拥塞控制算法**来减小传输速率。

### TCP 拥塞控制算法

![image-20210324160702236](https://static01.imgkr.com/temp/61a64397b336456692ed71ae4359e123.png)

#### 慢启动

当一条 TCP 连接开始时，cwnd 的初始值通常置为 1MSS。但实际上可用带宽可能比 MSS/RTT 大得多，所以发送方希望**迅速**找到可用的带宽数量。因此，在慢启动阶段，cwnd 的值以 1MSS 开始并且**每当**传输的报文段首次被确认就增加 1MSS。

> 举例：发送方发送了一个报文段，当它收到确认时，增加发送速率到 2MSS，同时发送**两个报文段**（因为发送速率提高了），当它们被确认时，增加发送速率到 4MSS，每次翻番。所以，TCP 发送速率在慢启动阶段是以**指数**增长的。

**结束指数增长的时机**：

- **超时**：将第二个状态变量的值 ssthresh（慢启动阈值）设置为 cwnd / 2，即当检测到拥塞时将 sshresh 置为拥塞窗口值的一半，并将 cwnd 设置为 1MSS 并**重新开始慢启动**，
- **当 cwnd 达到或超过 ssthresh**：说明已经**接近**上次的阈值了，如果 cwnd 再继续以指数增长，很有可能会导致拥塞，所以结束慢启动并且切换到**拥塞避免**模式。
- **检测到 3 个冗余 ACK**：TCP 对于这种丢包行为，相比于超时**不应该**这么剧烈。**将 ssthresh 设置为 cwnd / 2，并且将 cwnd 减半，但要考虑到已收到的 3 个冗余 ACK，使 cwnd 加上 3MSS**，<span id="#quick-transmit">快速重传</span>进入**快速恢复**状态。

#### 拥塞避免

一旦进入拥塞避免状态，cwnd 的值大约是上次遇到拥塞时值的一半。此时，TCP 发送方的发送速率最好**不要再以指数速度增长**，所以采用一种更为保守的办法：**每经过一个 RTT 才将 cwnd 的值增加 1MSS**，这时为**线性增长**。

> 举例：比如 MSS 是 1460 字节，而 cwnd 是 14600 字节，则在一个 RTT 内发送 10 个（即 cwnd/MSS 个）报文段，每个到达的 ACK 使 cwnd 增加 1/10（MSS/cwnd） 个 MSS 的值。

**结束线性增长的时机：**

- **超时**：**和慢启动时的策略一致**，将 ssthresh 设置为 cwnd / 2，并将 cwnd 设置为 1MSS 并切换到**慢启动**状态。
- **检测到 3 个冗余 ACK**：**和慢启动时策略一致**，将 ssthresh 设置为 cwnd / 2，并将 cwnd 设置为 **cwnd / 2 + 3MSS**，进入**快速恢复**状态。

#### 快速恢复

快速恢复是推荐部分，对 TCP 发送方**并非必需**，在 TCP 的较新版本 TCP Reno 中使用。在快速恢复状态中，发送方对收到的每一个**冗余 ACK**，cwnd 都增加 1MSS。

**cwnd 结束增加的时机**：

- 超时：**和慢启动时的策略一致**，将 ssthresh 设置为 cwnd / 2，并将 cwnd 设置为 1MSS 并切换到**慢启动**状态。
- 收到一个对于**丢失报文段**的 ACK（非冗余 ACK）：置 cwnd 值**等于** ssthresh （即减小 cwnd）并切换到**拥塞避免**状态。

> 举例：
>
> 下图中，TCP Tahoe 在收到 3 个冗余 ACK 时直接将 cwnd 置为 1MSS 进入慢启动状态，而 TCP Reno 则是将 cwnd 置为 ssthresh(减半后的) + 3MSS 并进入快速恢复状态。
>
> ![image-20210324160831810](https://static01.imgkr.com/temp/993dd92c1b134a16aea29b0592aba89f.png)

### 拥塞控制回顾

TCP 的拥塞控制是：忽略慢启动阶段，每个 RTT 内 cwnd 线性（加性）增加 1MSS，然后出现 3 个冗余 ACK 事件时 cwnd 减半（乘性）。因此，TCP 拥塞控制常常被称为**加性增、乘性减（AIMD）**拥塞控制方式。所以，这种拥塞控制会引发一种“锯齿”行为，即 TCP 传输速率（拥塞窗口长度）线性增加到一定程度会乘性**突减**。

![image-20210324172220657](https://static01.imgkr.com/temp/36ac0e966c79444481263263b74bf72f.png)

许多 TCP 实现采用 Reno 算法，其一个变种 Vegas 算法试图在维持较好的吞吐量的同时避免拥塞，基本思想是：① 在分组丢失之前，在源与目的地之间检测路由器中的拥塞；② 当检测到**快要**发生的分组丢失时，**线性**地降低发送速率。快要发生地分组丢失是通过**观察 RTT**来**预测**的，分组的 RTT 越长，路由器中的拥塞越严重。

#### TCP 连接的平均吞吐量

- 因为是指数增长，所以可以忽略慢启动阶段。

- 在一个特定的往返间隔内，TCP 发送数据的速率是**拥塞窗口与当前 RTT 的函数**。当窗口长度是 $w$（个 MSS），往返时间是 RTT 秒，则 TCP 的发送速率大约是 $w/RTT$(MSS/s)。于是，TCP 每经一个 RTT 就将 $w$ 增加 1(MSS)，直到发生丢包事件，将 $w$ 的值**减半**。当发生丢包时，用 $W$ 表示 $w$ 的值（即拥塞窗口最大值），假设连接持续期间 RTT 和 $W$ 几乎不变，那么 TCP 的传输速率在 $[\frac{W}{2×RTT}, \frac{W}{RTT}]$ （单位是 MSS/s）之间变化。

- 假设 TCP 稳态行为就简化为：当速率增长至 $\frac{W}{RTT}$ 时，分组丢失，发送速率减半，然后每过一个 RTT 发送速率就增加 1MSS/RTT（因为 $w$ = $w$ + MSS），直到再次到达 $\frac{W}{RTT}$ 为止。这一过程不断重复。所以，一条连接的平均吞吐量为：

  $$\frac{0.75×W}{RTT}$$(MSS/s)，**当无丢包**时显然成立。

  此时可能的丢包率为：

  $$\frac{1}{\frac{3W^2}{8}+\frac{3W}{4}}$$

  > 证明：
  >
  > 因为拥塞窗口**每经过 1RTT 就增加 1MSS，并发送 $w$ 个分组**，所以拥塞窗口大小 $w$ 从 $\frac{W}{2}(MSS)$ 增长到 $W(MSS)$ 期间发送的分组个数为：
  >
  > $\frac{W}{2} + (\frac{W}{2}+1) + (\frac{W}{2}+2) +\dots + W\\ =\sum_{n=0}^{\frac{W}{2}}(\frac{W}{2}+n)\\ =(\frac{W}{2}+1)* \frac{W}{2}+\sum_{n=0}^{\frac{W}{2}}n\\ =\frac{W^2}{4}+\frac{W}{2}+\frac{\frac{W}{2}*(\frac{W}{2}+1)}{2}\\ =\frac{3W^2}{8}+\frac{3W}{4}$
  >
  > 所以，丢包率为**丢失的分组/总的发送分组**，即：
  >
  > $$L=\frac{1}{\frac{3W^2}{8}+\frac{3W}{4}}$$

- 当存在丢包时，一条连接的平均吞吐量为：

  $$\frac{1.22}{RTT\sqrt{L}}$$(MSS/s)

    > 证明：
    >
    > 由上面可知，发送的分组总个数为$\frac{3W^2}{8}+\frac{3W}{4}$，而对于很大的窗口：
    >
    > $$\frac{3W^2}{8} >> \frac{3W}{4}$$
    >
    > 所以，可以忽略一次项，认为发送的总分组数为：
    >
    > $$L=\frac{8}{3W^2}$$
    >
    > 进而推出：
    >
    > $$W=\sqrt{\frac{8}{3L}}$$
    >
    > 所以，得出平均吞吐量为：
    >
    > $\frac{0.75×W}{RTT}\\ =\frac{0.75×\sqrt{\frac{8}{3L}}}{RTT}\\ =\frac{1.22}{RTT\sqrt{L}}$

### 公平性

TCP 趋于在竞争的多条 TCP 连接之间提供一段瓶颈链路带宽的**平等分享**。

![image-20210324165442181](https://static01.imgkr.com/temp/3417c96ad06f4dc793ea32007134649a.png)

- 假定某时刻连接 1 和连接 2 在 A 点指明的吞吐量，因为两条连接消耗的总链路带宽量小于 R，无丢包事件发生，所以这两条连接每过一个 RTT 都要将其窗口增加 1MSS。所以，从 A 点开始沿 45° 线前行（增长速率一致）。
- 最终，到达 B 点，总带宽将超过 R，分组丢失，它们都会将其窗口减半，到达 C 点。又回到了类似 A 点的状态，一直循环往复，在**平等带宽共享曲线附近波动**。

但实际上，**具有较小 RTT 的连接**能够在链路空闲时**更快地**强到可用带宽（因为更快地打开其拥塞窗口），因而将比那些具有较大 RTT 的连接享用更高的吞吐量。

另一方面，没有拥塞控制的 UDP 连接也很有可能**压制** TCP 流量。

某个应用程序若同时使用**多个** TCP **并行**连接，也会不公平地抢占过多的带宽。

### 明确拥塞通告：网络辅助拥塞控制

- 在网络层，IP 数据报首部的服务类型字段中用两个比特被用于 ECN。**路由器**所使用的一种 **ECN 比特**设置指示该路由器正在历经拥塞。该拥塞指示被标记的 IP 数据报携带，发送给目的主机，再由**目的主机**通过在 TCP ACK 报文中**设置 ECE 比特**来通知发送主机。
- 发送主机通过减半拥塞窗口对一个拥有 ECE 拥塞指示的 ACK 作出反应，并且在下一个传输的报文中对 **CWR（拥塞窗口缩减）比特**进行设置。

## 3.8 小结

- UDP 仅提供多路复用/分解功能
- TCP 有着可靠交付、时延保证和带宽保证
  - 可靠交付用到的技术：确认、定时器、重传、序号、检验和、窗口与流水线（还有选择确认等技术）
  - 时延保证和带宽保证用到的技术：连接管理、流量控制、往返时间估计、拥塞控制
- 其他协议：
  - 数据报拥塞控制协议（DCCP）：提供了一种低开销、面向报文、类似于 UDP 的不可靠服务，但是具有应用程序可选择的拥塞控制形式，该机制与 TCP 相兼容。DCCP 被设想用于诸如**流媒体**等应用程序中，DCCP 能够利用数据交付的预定时间和可靠性的折中，但是要对网络拥塞做出响应
  - QUIC 协议：该协议通过重传以及差错检测、快速连接建立和基于速率的拥塞控制算法提供可靠性，而基于速率的拥塞控制算法是以 TCP 友好特性为目标，这些机制都是**在 UDP 之上作为应用层协议实现**的
  - DCTCP（数据中心 TCP）协议：专门用于数据中心网络的 TCP 版本，使用 ECN 以更好地支持短流和长流的混合流，这种混合流代表了数据中心负载的特征
  - 流控制传输协议（SCTP）：是一种可靠的、面向报文的协议，该协议允许几个不同的应用层次的流复用到单个 SCTP（一种称之为“多流”的方法）连接上。从可靠性的角度看，在该连接中的不同流被分别处理，因此在一条流中的分组丢失不会影响其他流中数据的交付。当一台主机与两个或更多个网络连接时，SCTP 也允许数据经两条出路径传输，还具有失序数据的选项交付和一些其他特色。SCTP 的流控制和拥塞控制算法基本上与 TCP 中相同。
  - TCP 友好速率协议（TFRC）：是一种**拥塞控制协议**而不是一种功能齐全的运输层协议。它定义了一种拥塞控制机制，该机制能被用于诸如 DCCP 等其他运输协议。TFRC 的目标是**平滑在 TCP 拥塞控制中的“锯齿”行为**，同时维护一种长期的发送速率，该速率合理地接近 TCP 的速率。TFRC 非常适合诸如 IP 电话或流媒体等多媒体应用。TFRC 是一种**基于方程**的协议，这些协议使用测得的丢包率作为方程的输入，即**使用方程估计一个 TCP 会话在该丢包率下 TCP 的吞吐量将是多大**。该速率被取为 TFRC 的目标发送速率。

  ## 英文术语

|        中文         |                    英文                    | 英文缩写 |
| :-----------------: | :----------------------------------------: | :------: |
|      逻辑通信       |            logic communication             |          |
|       报文段        |                  segment                   |          |
|  尽力而为交付服务   |        best-effort delivery service        |          |
|     不可靠服务      |             unreliable service             |          |
|      多路复用       |                multiplexing                |          |
|      多路分解       |               demultiplexing               |          |
|    可靠数据传输     |           reliable data transfer           |          |
|      拥塞控制       |             congestion control             |          |
|        线程         |                   thread                   |          |
|     端到端原则      |             end-end principle              |          |
|    单向数据传输     |        unidirectional data transfer        |          |
|    双向数据传输     |        bidirectional data transfer         |          |
|      肯定确认       |          positive acknowledgment           |   ACK    |
|      否定确认       |          negative acknowledgment           |   NAK    |
|    自动重传请求     |          Automatic Repeat reQuest          |   ARQ    |
|        停等         |               stop-and-wait                |          |
|      冗余分组       |              duplicate packet              |          |
|        序号         |              sequence number               |          |
|    倒计数定时器     |              countdown timer               |          |
|    比特交替协议     |          alternating-bit protocol          |          |
|       利用率        |                utilization                 |          |
|      回退 N 步      |                 Go-Back-N                  |   GBN    |
|      选择重传       |              Selective Repeat              |    SR    |
|    滑动窗口协议     |          sliding-window protocol           |          |
|      累计确认       |         cumulative acknowledgment          |          |
|   基于事件的编程    |          event-based programming           |          |
|     面向连接的      |            connection-oriented             |          |
|   用户数据报协议    |           User Datagram Protocol           |   UDP    |
|    传输控制协议     |       Transmission Control Protocol        |   TCP    |
|     全双工服务      |            full-duplex service             |          |
|       点对点        |               point-to-point               |          |
|      发送缓存       |                send buffer                 |          |
|      三次握手       |            three-way handshake             |          |
|   最大报文段长度    |            Maximum Segment Size            |   MSS    |
|    最大传输单元     |         Maximum Transmission Unit          |   MTU    |
|    紧急数据指针     |            urgent data pointer             |          |
|        捎带         |                piggybacked                 |          |
|  指数加权移动平均   |    Exponential Weighted Moving Average     |   EWMA   |
|      快速重传       |              fast retransmit               |          |
|      选择确认       |          selective acknowledgment          |          |
|    流量控制服务     |            flow-control service            |          |
|    SYN 洪范攻击     |              SYN flood attack              |          |
|   没连接的吞吐量    |         per-connection throughput          |          |
|      供给载荷       |                offered load                |          |
|     可用比特率      |            Available Bite Rate             |   ABR    |
|      阻塞分组       |                choke packet                |          |
|       自计时        |               self-clocking                |          |
|    拥塞控制算法     |        congestion control algorithm        |          |
|       慢启动        |                 slow-start                 |          |
|      拥塞避免       |            congestion avoidance            |          |
|      快速恢复       |               fast recovery                |          |
|      TCP 分岔       |               TCP splitting                |          |
|   加性增、乘性减    | Additive-Increase, Multiplicative-Decrease |   AIMD   |
|    明确拥塞通告     |      Explicit Congestion Notification      |   ECN    |
| 数据报拥塞控制协议  |    Datagram Congestion Control Protocol    |   DCCP   |
| 快速 UDP 互联网连接 |       Quick UDP Internet Connection        |   QUIC   |
|   流控制传输协议    |    Stream Control Transmission Protocol    |   SCTP   |
|  TCP 友好速率控制   |         TCP-Friendly Rate Control          |   TFRC   |