---
title: 数据库原理——数据库完整性
date: 2020-05-13 9:25:10
tags: 
- Database
categories:
- Database
toc: true
reward: true
---

## 数据库完整性概述

数据库的完整性指数据的**正确性**和**相容性**。

- **正确性**：符合现实世界语义、反映当前实际状况；
- **相容性**：数据库同一对象在不同关系表中的数据是符合逻辑的。

::: tip
完整性和安全性**不是**一个概念。
- 数据的完整性是为了防止数据库中存在**不合语义**的数据，即防止出现不正确的数据
- 数据的安全性是保护数据库**防止恶意破坏和非法存取**
:::

分为**实体完整性、参照完整性、用户定义的完整性**。

**维护数据库完整性的功能需要**：

- 提供定义完整性约束条件的机制（**完整性检查**，一般在**增删改**时开始检查）
- 提供完整性检查的方法
- 进行违约处理：**拒绝执行、级联操作、其他操作**

## 实体完整性

- 实体完整性包括列级和表级
- DBMS 对实体完整性的检查包括：
  - 检查主码值是否唯一
  - 检查主码的各个属性是否为空，只要有一个为空就拒绝执行
- 完整性检查：
  - 全表扫描
  - 建立索引
    - $B+$ 树：平衡树

## 参照完整性

违约处理策略：

- 拒绝执行（一般为默认策略）`NO ACTION`
- 级联操作 `CASCADE`
- 设置为空值 `SET NULL`

可以显式说明参照完整性的违约处理：

```sql
-- 当删除 Student 表中的元组时，级联删除 SC 表中相应的元组
CONSTRAINT FKS FOREIGN KEY(Sno) REFERENCES Student(Sno) ON DELETE CASCADE
```

> 因此，对于参照完整性，除了应该定义外码，还应该定义外码列是否允许空值

## 用户定义的完整性

一般是**针对某一应用的数据**

- `NOT NULL` 列值非空
- `DEFAULT` 默认值
- `CHECK` 检查 可以用于**元组级**的限制
- `UNIQUE` 唯一性

> 对于属性和元组上的约束条件，若不满足则操作会被拒绝执行

**不同的增删改**：

- `CREATE: ALTER ADD DROP` 对象级
- `INSERT: UPDATE INSERT DELETE` 数据级

## 断言

```CREATE AEESRTION <断言名> <CHEKC 子句>```

- 通过声明性判断来指定更具一般性的约束
- 可以定义设计**多个表**或**聚集操作**的比较复杂的完整性约束
- 如果断言很复杂，系统在维护和检测断言的开销较高，应谨慎使用

## 🔺触发器(trigger​) 
> 也叫事件-条件-动作($event-condition-action$)规则

- **用户**定义在**关系表**上的一类由**事件驱动**的特殊过程。
- 触发器一经定义，便保存在**数据库的服务器中**
- **增删改**可以触发触发器，增删改时对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，可以涉及其它表和其他数据库对象，**通常是一段 `SQL` 过程。**
- 触发器可以实现更为复杂的检查

### 触发器规则

- **只有表的拥有者（创建者）**，可以在表上创建触发器，一张表上只能创建一定数量的触发器。
- 触发器名可以包含模式名，也可以不包括模式名。**同一模式下，触发器名必须是唯一的，并且触发器名和表名必须在同一模式下。**
- **触发器只能定义在基本表上，不能定义在视图上。**
- **触发事件可以是 `INSERT、DELETE、UPDATE`，也可以是这几个事件的组合。`AFTER/BEFORE` 是触发的时机。**
- 触发器类型
  - 行级触发器 `FOR EACH ROW`
  - 语句级触发器 `FOR EACH STATEMENT`
  
  > 例子：有一个 `AFTER UPDATE` 触发器，触发事件为：`UPDATE TEACHER SET Deptno = 5`
  >
  > 假设表 `TEACHER` 有 `1000` 行，如果定义的触发器为语句级触发器，那么执行完 `UPDATE` 语句后触发动作体**执行一次**；如果是行级触发器，触发动作体将**执行 `1000` 次**
- 触发条件：只有当触发条件为真时触发动作体才执行。
- 触发动作体**既可以是一个匿名 `PL/SQL` 过程块，也可以是对已创建存储过程的调用。**使用**行级触发器**，用户在过程体中使用 **`NEW` 和 `OLD` 引用 `UPDATE/INSERT` 事件之后的新值与旧值**；**如果是语句级触发器，则不能引用**。
  - 有 `FOR EACH ROW` 可以引用 `OLDROW` 和 `NEWROW` 
  - 如果没有，则只能引用 `OLDTABLE` 和 `NEWTABLE`

::: tip
`SQL Server` 中引用新值和旧值通过 `INSERTED` 和 `DELETED`
:::

### 触发器执行顺序

1. 执行该表上 `BEFORE` 触发器
2. 执行激活触发器的 `SQL` 语句
3. 执行该表上的 `AFTER` 语句

> 对于同一个表上的多个 `BEFORE/AFTER` 触发器，遵循**谁先创建谁先执行**的原则。（有些关系数据库按照触发器名称的字典序执行）